import json
from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class CodeGenerator:
    """Service to generate Python code from workflow data for trading strategies"""
    
    def __init__(self):
        self.node_processors = {
            'data_source': self._process_data_source,
            'indicator': self._process_indicator,
            'condition': self._process_condition,
            'signal': self._process_signal,
            'order': self._process_order,
            'risk_management': self._process_risk_management,
            'output': self._process_output
        }
    
    def generate_strategy_code(self, workflow_data: Dict[str, Any], strategy_name: str) -> Dict[str, Any]:
        """
        Generate Python trading strategy code from workflow data
        
        Args:
            workflow_data: Dictionary containing nodes and edges
            strategy_name: Name of the strategy
            
        Returns:
            Dictionary with generated code, requirements, and metadata
        """
        # Validate workflow data
        if not isinstance(workflow_data, dict) or 'nodes' not in workflow_data or 'edges' not in workflow_data:
            logger.error("Invalid workflow data format")
            return {
                'success': False,
                'code': '',
                'requirements': [],
                'metadata': {},
                'errors': [{'error': 'Invalid workflow data format', 'type': 'validation_error'}]
            }
        
        nodes = workflow_data.get('nodes', [])
        edges = workflow_data.get('edges', [])
        
        try:
            # Build and validate node graph
            node_graph = self._build_node_graph(nodes, edges)
            
            # Generate code sections
            imports = self._generate_imports()
            class_definition = self._generate_class_definition(strategy_name)
            init_method = self._generate_init_method(nodes)
            strategy_logic = self._generate_strategy_logic(node_graph)
            
            # Combine code sections
            full_code = '\n'.join([imports, class_definition, init_method, strategy_logic])
            
            requirements = self._generate_requirements(nodes)
            
            return {
                'success': True,
                'code': full_code,
                'requirements': requirements,
                'metadata': {
                    'strategy_name': strategy_name,
                    'nodes_count': len(nodes),
                    'edges_count': len(edges),
                    'generated_at': datetime.utcnow().isoformat()
                },
                'errors': []
            }
            
        except Exception as e:
            logger.error(f"Error generating code: {str(e)}")
            return {
                'success': False,
                'code': '',
                'requirements': [],
                'metadata': {},
                'errors': [{'error': str(e), 'type': 'generation_error'}]
            }
    
    def _build_node_graph(self, nodes: List[Dict], edges: List[Dict]) -> Dict[str, Any]:
        """Build a graph representation of the workflow with validation"""
        graph = {}
        node_ids = {node['id'] for node in nodes}
        
        # Initialize graph with nodes
        for node in nodes:
            graph[node['id']] = {
                'node': node,
                'inputs': [],
                'outputs': []
            }
        
        # Validate and add edges
        for edge in edges:
            source_id = edge.get('source')
            target_id = edge.get('target')
            if source_id not in node_ids or target_id not in node_ids:
                raise ValueError(f"Edge references non-existent node: {edge}")
            graph[source_id]['outputs'].append(target_id)
            graph[target_id]['inputs'].append(source_id)
        
        return graph
    
    def _generate_imports(self) -> str:
        """Generate import statements"""
        return '''import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import talib
from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)
'''
    
    def _generate_class_definition(self, strategy_name: str) -> str:
        """Generate class definition with configurable parameters"""
        class_name = strategy_name.replace(' ', '').replace('-', '')
        return f'''class {class_name}Strategy:
    """
    Auto-generated trading strategy: {strategy_name}
    Generated by Alphintra No-Code Platform
    """
    
    def __init__(self, parameters: Dict[str, Any], initial_capital: float = 100000):
        self.parameters = parameters
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.positions = {{}}
        self.trades = []
        self.indicators = {{}}
        self.setup_indicators()
    '''
    
    def _generate_init_method(self, nodes: List[Dict]) -> str:
        """Generate initialization method with parameters from nodes"""
        params_code = ''
        for node in nodes:
            node_data = node.get('data', {})
            if 'parameters' in node_data:
                for param, value in node_data['parameters'].items():
                    params_code += f'        self.{param} = self.parameters.get("{param}", {repr(value)})\n'
        
        return f'''    def setup_indicators(self):
        """Initialize indicators and parameters"""
        logger.info(f"Strategy initialized with parameters: {{self.parameters}}")
{params_code}'''
    
    def _generate_strategy_logic(self, node_graph: Dict[str, Any]) -> str:
        """Generate main strategy logic with node processing"""
        logic_code = '''
    def process_data(self, data: pd.DataFrame) -> Dict[str, Any]:
        """
        Process market data and generate trading signals
        
        Args:
            data: DataFrame with OHLCV data
            
        Returns:
            Dictionary with signals and analysis
        """
        try:
            context = {}
            results = {
                'signals': [],
                'indicators': {},
                'conditions': [],
                'orders': []
            }
            current_data = data
            
            # Process nodes in topological order
'''
        processed = set()
        entry_points = [nid for nid, ninfo in node_graph.items() if not ninfo['inputs']]
        for node_id in entry_points:
            logic_code += self._process_node_recursive(node_graph, node_id, processed)
        
        logic_code += '''
            return results
            
        except Exception as e:
            logger.error(f"Error processing data: {str(e)}")
            return {'error': str(e)}
    
    def backtest(self, data: pd.DataFrame, start_date: str = None, end_date: str = None) -> Dict[str, Any]:
        """Run backtest on historical data"""
        try:
            if start_date:
                data = data[data.index >= start_date]
            if end_date:
                data = data[data.index <= end_date]
            
            for i in range(len(data)):
                current_data = data.iloc[:i+1]
                if len(current_data) < 50:  # Minimum data check
                    continue
                results = self.process_data(current_data)
                for order in results.get('orders', []):
                    self._execute_order(order, current_data.iloc[-1])
            
            return self._calculate_performance()
        except Exception as e:
            logger.error(f"Backtest error: {str(e)}")
            return {'error': str(e)}
    
    def _execute_order(self, order: Dict[str, Any], current_price_data: pd.Series):
        """Execute a trading order"""
        try:
            symbol = order.get('symbol', 'DEFAULT')
            side = order.get('side', 'buy')
            quantity = order.get('quantity', 0)
            price = current_price_data['close']
            
            if side == 'buy' and quantity * price <= self.current_capital:
                self.current_capital -= quantity * price
                self.positions[symbol] = self.positions.get(symbol, 0) + quantity
                self.trades.append({'side': side, 'quantity': quantity, 'price': price})
            elif side == 'sell' and self.positions.get(symbol, 0) >= quantity:
                self.current_capital += quantity * price
                self.positions[symbol] -= quantity
                self.trades.append({'side': side, 'quantity': quantity, 'price': price})
        except Exception as e:
            logger.error(f"Order execution error: {str(e)}")
    
    def _calculate_performance(self) -> Dict[str, Any]:
        """Calculate strategy performance metrics"""
        try:
            total_return = ((self.current_capital - self.initial_capital) / self.initial_capital) * 100
            total_trades = len(self.trades)
            winning_trades = sum(1 for trade in self.trades if trade['side'] == 'sell')
            return {
                'total_return': total_return,
                'total_trades': total_trades,
                'winning_trades': winning_trades,
                'final_capital': self.current_capital
            }
        except Exception as e:
            logger.error(f"Performance calculation error: {str(e)}")
            return {'error': str(e)}
'''
        return logic_code
    
    def _process_node_recursive(self, node_graph: Dict[str, Any], node_id: str, processed: set) -> str:
        """Process a node and its dependencies recursively"""
        if node_id in processed:
            return ''
        processed.add(node_id)
        node_info = node_graph[node_id]
        node = node_info['node']
        node_type = node.get('type', 'unknown')
        input_vars = [f"context['{nid}']" for nid in node_info['inputs']]
        
        code = self.node_processors.get(node_type, lambda n, iv: f"# Unknown node type: {node_type}\n")(node, input_vars)
        code = f"            context['{node_id}'] = {code}\n"
        
        for output_id in node_info['outputs']:
            code += self._process_node_recursive(node_graph, output_id, processed)
        return code
    
    def _process_data_source(self, node: Dict[str, Any], input_vars: List[str]) -> str:
        """Process data source node"""
        if input_vars:
            return '"# Error: data_source should have no inputs"'
        return 'current_data.copy()'
    
    def _process_indicator(self, node: Dict[str, Any], input_vars: List[str]) -> str:
        """Process indicator node"""
        if len(input_vars) != 1:
            return '"# Error: indicator requires one input (data)"'
        data_var = input_vars[0]
        node_data = node.get('data', {})
        ind_type = node_data.get('indicator_type', 'sma')
        period = node_data.get('period', 20)
        if ind_type == 'sma':
            return f"talib.SMA({data_var}['close'], timeperiod={period}) if len({data_var}) >= {period} else pd.Series(np.nan, index={data_var}.index)"
        elif ind_type == 'ema':
            return f"talib.EMA({data_var}['close'], timeperiod={period}) if len({data_var}) >= {period} else pd.Series(np.nan, index={data_var}.index)"
        elif ind_type == 'rsi':
            return f"talib.RSI({data_var}['close'], timeperiod={period}) if len({data_var}) >= {period} else pd.Series(np.nan, index={data_var}.index)"
        return f'"{ind_type}_data"  # Placeholder for unsupported indicator'
    
    def _process_condition(self, node: Dict[str, Any], input_vars: List[str]) -> str:
        """Process condition node"""
        if len(input_vars) != 1:
            return '"# Error: condition requires one input"'
        input_var = input_vars[0]
        node_data = node.get('data', {})
        cond_type = node_data.get('condition_type', 'above_value')
        value = node_data.get('value', 0)
        if cond_type == 'above_value':
            return f"{input_var}.iloc[-1] > {value} if not pd.isna({input_var}.iloc[-1]) else False"
        elif cond_type == 'below_value':
            return f"{input_var}.iloc[-1] < {value} if not pd.isna({input_var}.iloc[-1]) else False"
        return 'False  # Unsupported condition'
    
    def _process_signal(self, node: Dict[str, Any], input_vars: List[str]) -> str:
        """Process signal node"""
        if len(input_vars) != 1:
            return '"# Error: signal requires one input (condition)"'
        cond_var = input_vars[0]
        node_data = node.get('data', {})
        sig_type = node_data.get('signal_type', 'buy')
        return f"results['signals'].append({{'type': '{sig_type}', 'timestamp': current_data.index[-1]}}) if {cond_var} else None"
    
    def _process_order(self, node: Dict[str, Any], input_vars: List[str]) -> str:
        """Process order node"""
        if len(input_vars) != 1:
            return '"# Error: order requires one input (signal)"'
        sig_var = input_vars[0]
        node_data = node.get('data', {})
        side = node_data.get('side', 'buy')
        quantity = node_data.get('quantity', 100)
        return f"results['orders'].append({{'side': '{side}', 'quantity': {quantity}, 'symbol': 'DEFAULT'}}) if {sig_var} is not None else None"
    
    def _process_risk_management(self, node: Dict[str, Any], input_vars: List[str]) -> str:
        """Process risk management node (placeholder)"""
        return '"# Risk management placeholder"'
    
    def _process_output(self, node: Dict[str, Any], input_vars: List[str]) -> str:
        """Process output node"""
        return 'results  # Return accumulated results'
    
    def _generate_requirements(self, nodes: List[Dict]) -> List[str]:
        """Generate required Python packages"""
        reqs = ['pandas>=1.3.0', 'numpy>=1.21.0', 'talib>=0.4.0']
        if any(node.get('type') == 'machine_learning' for node in nodes):
            reqs.append('scikit-learn>=1.0.0')
        return reqs